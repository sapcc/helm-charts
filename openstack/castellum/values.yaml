global:
  registry: DEFINED_IN_VALUES_FILE
  linkerd_requested: true

linkerd-support:
  annotate_namespace: true

owner-info:
  support-group: containers
  service: castellum
  maintainers:
    - Stefan Majewsky
    - Sandro JÃ¤ckel
  helm-chart-url: https://github.com/sapcc/helm-charts/tree/master/openstack/castellum

castellum:
  image_tag: null # must be set by CI pipeline
  asset_managers: [ nfs-shares, server-groups ]

  # List of project seeds. Entries must follow the same format as in the castellum.yaml config file,
  # described in <https://github.com/sapcc/castellum/blob/master/README.md#building-and-running>
  project_seeds: []

  # List of max_asset_sizes constraints. Entries must for the most part follow
  # the same format as in the castellum.yaml config file, described in
  # <https://github.com/sapcc/castellum/blob/master/README.md#building-and-running>.
  # Also, all entries must have the key "region". They will only be considered
  # if "region" has the value "any" or a value equal to .Values.global.region.
  max_asset_sizes: []

postgresql:
  persistence:
    enabled: true
    size: 10Gi
  postgresDatabase: castellum
  users:
    castellum: {}
  tableOwner: castellum

  config:
    log_min_duration_statement: 250
    # 2 api * 16 + 2 workers * 16 + 1 observer * 16 + headroom for metrics/backup and admin access
    max_connections: 96

  alerts:
    support_group: containers

  resources:
    limits: &postgres-limits
      memory: 512Mi
      cpu: '1'
    requests: *postgres-limits

pgbackup:
  isPostgresNG: true
  database:
    name: castellum
  alerts:
    support_group: containers

pgmetrics:
  isPostgresNG: true
  db_name: castellum

  alerts:
    support_group: containers

  collectors:
    stat_bgwriter: false

  customMetrics:
    castellum_asset_count:
      query: >
        SELECT r.asset_type AS asset, COUNT(a.id) AS gauge
          FROM resources r
          LEFT OUTER JOIN assets a ON a.resource_id = r.id
         GROUP BY r.asset_type
      metrics:
        - asset:
            usage: "LABEL"
            description: "Asset type"
        - gauge:
            usage: "GAUGE"
            description: "Total number of assets that are managed by Castellum"
    castellum_resource_count:
      query: >
        SELECT asset_type AS asset, COUNT(id) AS gauge
          FROM resources
         GROUP BY asset_type
      metrics:
        - asset:
            usage: "LABEL"
            description: "Asset type"
        - gauge:
            usage: "GAUGE"
            description: "Total number of resources where autoscaling is enabled"

    # The final UNION SELECT adds a dummy row that always exists even when no
    # pending operations exist. This allows us to have our cake and eat it (we
    # don't insert unnecessary timeseries, but the absence alert generated by
    # the absent-metrics-operator is still useful).
    castellum_min_greenlit_at:
      query: >
        SELECT r.scope_uuid AS project_id, r.asset_type AS asset, EXTRACT(epoch FROM MIN(o.greenlit_at)) AS gauge
          FROM resources r
          JOIN assets a ON a.resource_id = r.id
          JOIN pending_operations o ON o.asset_id = a.id
         WHERE o.greenlit_at IS NOT NULL
         GROUP BY r.scope_uuid, r.asset_type
         UNION SELECT 'none' AS project_id, 'none' AS asset, EXTRACT(epoch FROM NOW()) AS gauge
      metrics:
        - project_id:
            usage: "LABEL"
            description: "UUID of project"
        - asset:
            usage: "LABEL"
            description: "Asset type"
        - gauge:
            usage: "GAUGE"
            description: "Lowest greenlit_at timestamp of any pending operation in this project resource"
    castellum_resource:
      query: >
        SELECT asset_type AS asset, MIN(next_scrape_at) AS min_next_scrape_at
          FROM resources
         GROUP BY asset_type
      metrics:
        - asset:
            usage: "LABEL"
            description: "Asset type"
        - min_next_scrape_at:
            usage: "GAUGE"
            description: "Lowest next_scrape_at timestamp of any project resource with this asset type"
    castellum_asset:
      query: >
        SELECT r.asset_type AS asset, MIN(a.next_scrape_at) AS min_next_scrape_at
          FROM resources r
          JOIN assets a ON a.resource_id = r.id
          GROUP BY r.asset_type
      metrics:
        - asset:
            usage: "LABEL"
            description: "Asset type"
        - min_next_scrape_at:
            usage: "GAUGE"
            description: "Lowest next_scrape_at timestamp of any asset with this type"

    castellum_resource_scrape_errors:
      query: >
        SELECT COUNT(id) as gauge
          FROM resources
         WHERE scrape_error_message != ''
      metrics:
        - gauge:
            usage: "GAUGE"
            description: "Total number of resources that failed their last scrape"

    castellum_existing_asset_scrape_errors:
      query: >
        SELECT COUNT(id) as gauge
          FROM assets
         WHERE scrape_error_message != '' AND NOT never_scraped
      metrics:
        - gauge:
            usage: "GAUGE"
            description: "Total number of assets that failed their last scrape (only counting those assets that had at least one successful scrape ever)"

    castellum_fresh_asset_scrape_errors:
      query: >
        SELECT COUNT(id) as gauge
          FROM assets
         WHERE scrape_error_message != '' AND never_scraped
      metrics:
        - gauge:
            usage: "GAUGE"
            description: "Total number of assets that failed their last scrape (only counting those assets that never had a successful scrape)"

    castellum_asset_resize_errors:
      query: >
        WITH latest_finished_operations AS (
          SELECT DISTINCT ON (asset_id) o.* FROM finished_operations o
            JOIN assets a ON a.id = o.asset_id
          ORDER BY o.asset_id, o.finished_at DESC
        )
        SELECT COUNT(asset_id) as gauge
          FROM latest_finished_operations
         WHERE outcome = 'errored'
      metrics:
        - gauge:
            usage: "GAUGE"
            description: "Total number of assets that failed their last resize"

    # There is a lot to unpack in this query. Reading from the inside out:
    # 1. We want to be alerted when an asset is at a critical usage level, but
    #    Castellum is not doing anything about it. That's what the WHERE describes.
    #    (This used to just be something along the lines of `WHERE
    #    usage_percent > critical_threshold_percent`, but since multi-usage
    #    resources, Castellum has started evaluating this condition for us and
    #    reporting into the `critical_usages` column.)
    # 2. To quantify the "not doing anything" part, the metric value is the
    #    time since the last critical upsize was performed on that asset. We
    #    RIGHT OUTER JOIN instead of a simple JOIN since there may not be a
    #    finished operation for that asset at all.
    # 3. The inner SELECT query would be enough to power the alert. But if we
    #    do just that, we would be creating a ton of useless timeseries that live
    #    for only a few minutes. The timeseries appears when the asset is scraped
    #    and usage is critical, and it disappears in the next scrape after the
    #    size was adjusted. Since scrapes occur every 5 minutes, we only create
    #    the timeseries at the 6 minute mark, so most of them will be avoided.
    # 4. The final UNION SELECT adds a dummy row that always exists even when no
    #    critical assets are inactive. This allows us to have our cake and eat
    #    it (we don't insert unnecessary timeseries, but the absence alert
    #    generated by the absent-metrics-operator is still useful).
    castellum_critical_inactivity:
      query: >
        WITH currently_critical_assets AS (
          SELECT a.uuid AS asset_id, r.asset_type AS asset, COALESCE(EXTRACT(epoch FROM MAX(fo.finished_at)), 0) AS started_at
            FROM assets a
            JOIN resources r ON a.resource_id = r.id
           RIGHT OUTER JOIN finished_operations fo ON fo.asset_id = a.id AND fo.reason = 'critical'
           WHERE a.critical_usages != ''
           GROUP BY a.uuid, r.asset_type
        )
        SELECT * FROM currently_critical_assets WHERE started_at < EXTRACT(epoch FROM (NOW() - interval '6 minute'))
        UNION SELECT 'none' AS asset_id, 'none' AS asset, EXTRACT(epoch FROM NOW()) AS started_at
      metrics:
        - asset:
            usage: "LABEL"
            description: "Asset type"
        - asset_id:
            usage: "LABEL"
            description: "ID of affected asset"
        - started_at:
            usage: "GAUGE"
            description: "UNIX timestamp of last finished resize operation on this asset (presence of metric indicates that asset usage is critical for at least 1 minute)"
