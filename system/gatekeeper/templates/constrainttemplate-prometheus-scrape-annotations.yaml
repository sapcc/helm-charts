apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: gkprometheusscrapeannotations
spec:
  crd:
    spec:
      names:
        kind: GkPrometheusScrapeAnnotations

  targets:
    - target: admission.k8s.gatekeeper.sh
      libs:
        - |
          {{ .Files.Get "lib/add-support-labels.rego" | nindent 10 }}
      rego: |
        package prometheusscrapeannotations
        import data.lib.add_support_labels

        iro := input.review.object

        is_valid_target[target] {
          target := data.inventory.namespace[_]["monitoring.coreos.com/v1"].Prometheus[_].metadata.name
        }

        violation[{"msg": msg}] {
          # does this object have Prometheus scraping enabled at all?
          regex.match("^(?:Service|Pod)$", iro.kind)
          anno := object.get(iro, ["metadata", "annotations"], {})
          object.get(anno, "prometheus.io/scrape", "false") == "true"

          # check that prometheus.io/targets contains only valid values
          targets := regex.split("\\s*,\\s*", object.get(anno, "prometheus.io/targets", ""))
          count(targets) != count({t | t := targets[_]; is_valid_target[_] == t})
          # ^ NOTE: If the annotation is missing, we will have `targets == [""]` and that empty string value will count as invalid.

          all_valid_targets := {t | is_valid_target[t]}

          msgBase := sprintf(
            "has prometheus.io/scrape annotation, but prometheus.io/targets annotation is missing or does not have a valid value (got: %s, valid: %s)",
            [json.marshal(sort(targets)), json.marshal(sort(all_valid_targets))],
          )
          msg := add_support_labels.from_k8s_object(iro, msgBase)
        }
