{{- if .Capabilities.APIVersions.Has "templates.gatekeeper.sh/v1" }}
apiVersion: templates.gatekeeper.sh/v1
{{- else }}
apiVersion: templates.gatekeeper.sh/v1beta1
{{- end }}
kind: ConstraintTemplate
metadata:
  name: gkpodlabels
spec:
  crd:
    spec:
      names:
        kind: GkPodLabels
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          properties:
            osServices:
              type: string

  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package podlabels

        # Since we are going to have a lot of violations initially therefore we report on the
        # Deployment/DaemonSet level, where possible, to avoid useless duplication of violations.

        default os_services = []
        os_services = sort(split(input.parameters.osServices, "|"))

        # Defining variables because they are referenced in multiple places.
        alert_tier = "alert-tier"
        alert_service = "alert-service"

        # Either alert-tier or alert-service label is required. However, when alert-tier == os then alert-service is also required.
        required_labels = {alert_tier, alert_service}

        missing_labels_on_pod = [l |
          required_labels[l]
          not input.review.object.metadata.labels[l]
        ]

        missing_labels_on_pod_template = [l |
          required_labels[l]
          not input.review.object.spec.template.metadata.labels[l]
        ]

        pod_owners = {"ReplicaSet", "DaemonSet", "StatefulSet"}

        pod_belongs_to[kind] {
          ref := input.review.object.metadata.ownerReferences[_]
          kind := ref.kind
          kind == pod_owners[_]
        }

        violation[{"msg": msg}] {
          input.review.object.kind == "Pod"
          count(pod_belongs_to) == 0 # otherwise the violation will be reported on the DaemonSet or Deployment instead
          count(missing_labels_on_pod) == 2
          msg := sprintf("pod does not have either one of the required labels: %s", [sort(missing_labels_on_pod)])
        }

        violation[{"msg": msg}] {
          obj := input.review.object
          obj.kind == "Pod"
          count(pod_belongs_to) == 0 # otherwise the violation will be reported on the DaemonSet or Deployment instead

          t := object.get(obj.metadata.labels, alert_tier, "")
          t == "os"
          srv := object.get(obj.metadata.labels, alert_service, "")
          found := {f | srv == os_services[_]; f = true}
          count(found) == 0
          msg := sprintf(
            "pod has %q label with value: os, but %q label is missing or does not have a valid value (got: %s, valid: %s)",
            [alert_tier, alert_service, json.marshal(srv), os_services],
          )
        }

        violation_owners = {"Deployment", "DaemonSet", "StatefulSet"}

        violation[{"msg": msg}] {
          input.review.object.kind == violation_owners[_]
          count(missing_labels_on_pod_template) == 2
          msg := sprintf("pod does not have either one of the required labels: %s", [sort(missing_labels_on_pod_template)])
        }

        violation[{"msg": msg}] {
          obj := input.review.object
          obj.kind == violation_owners[_]

          t := object.get(obj.spec.template.metadata.labels, alert_tier, "")
          t == "os"
          srv := object.get(obj.spec.template.metadata.labels, alert_service, "")
          found := {f | srv == os_services[_]; f = true}
          count(found) == 0
          msg := sprintf(
            "pod has %q label with value: os, but %q label is missing or does not have a valid value (got: %s, valid: %s)",
            [alert_tier, alert_service, json.marshal(srv), os_services],
          )
        }
